<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Metodi euristici per partizionare in comunit√† Nella precedente parte sono stati introdotti i concetti cut-community e web-community, e dimostrato che il problema del partizionamento di un grafo in web-communities √® un problema difficile1 dal punto di vista computazionale."><title>ü™¥ Alessandro Straziota's Notes</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://Alessandrostr95.github.io//icon.png><link href=https://Alessandrostr95.github.io/styles.b3e1e36b0403ac565c9392b3e23ef3b6.min.css rel=stylesheet><link href=https://Alessandrostr95.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://Alessandrostr95.github.io/js/darkmode.ff3928c070aaa41dd4e6a0d10ab7e115.min.js></script>
<script src=https://Alessandrostr95.github.io/js/util.9825137f5e7825e8553c68ce39ac9e44.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://Alessandrostr95.github.io/js/popover.abe6a51cc7138c5dff00f151dd627ad1.min.js></script>
<script src=https://Alessandrostr95.github.io/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://Alessandrostr95.github.io/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://Alessandrostr95.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const BASE_URL="https://Alessandrostr95.github.io/",fetchData=Promise.all([fetch("https://Alessandrostr95.github.io/indices/linkIndex.375f0d3a5a0ffd5bd26bf2c0bde1ac8b.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://Alessandrostr95.github.io/indices/contentIndex.87f31d28119c572b32fecd67e52801c9.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://Alessandrostr95.github.io",!0,!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://Alessandrostr95.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/Alessandrostr95.github.io\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://Alessandrostr95.github.io/js/full-text-search.24827f874defbbc6d529926cbfcfb493.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://Alessandrostr95.github.io/>ü™¥ Alessandro Straziota's Notes</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><p class=meta>Last updated
Aug 29, 2022
<a href=https://github.com/Alessandrostr95/quartz/tree/hugo/content/AR/8%20-%20Communities%20-%20Part%202.md rel=noopener>Edit Source</a></p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#edge-betweenness>Edge-Betweenness</a></li><li><a href=#il-metodo-di-girvan-newman>Il metodo di Girvan-Newman</a></li><li><a href=#algoritmo-per-il-calcolo-della-betweenness>Algoritmo per il calcolo della betweenness</a><ol><li><a href=#fase-1>Fase 1</a></li><li><a href=#fase-2>Fase 2</a></li><li><a href=#fase-3>Fase 3</a></li><li><a href=#fase-finale---calcolo-betweenness>Fase finale - Calcolo Betweenness</a></li></ol></li></ol></nav></details></aside><a href=#metodi-euristici-per-partizionare-in-comunit√†><h1 id=metodi-euristici-per-partizionare-in-comunit√†><span class=hanchor arialabel=Anchor># </span>Metodi euristici per partizionare in comunit√†</h1></a><p>Nella precedente
<a href=/AR/7-Communities-Part-1/ rel=noopener class=internal-link data-src=/AR/7-Communities-Part-1/>parte</a> sono stati introdotti i concetti
<a href=/AR/7-Communities-Part-1/ rel=noopener class=internal-link data-src=/AR/7-Communities-Part-1/>cut-community</a> e
<a href=/AR/7-Communities-Part-1/ rel=noopener class=internal-link data-src=/AR/7-Communities-Part-1/>web-community</a>, e dimostrato che il problema del partizionamento di un grafo in web-communities √® un problema <strong>difficile</strong><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> dal punto di vista computazionale.</p><p>In questa parte verranno mostrate due famiglie approcci che dal punto di vista euristico riescono a partizionare un grafo in comunit√† accettabili, ovvero in gruppi di nodi abbastanza coesi tra di loro.</p><p>Pi√π precisamente i due metodi si dividono in:</p><ul><li><strong>metodi partitivi</strong>, in cui si parte considerando l&rsquo;intero grafo come unica grande comunit√†, e la si inizia a disconnettere (rimuovendo archi) finch√© non si otterranno due comunit√† distinte e coese. Se si desidera ottenere una <strong>granularit√†</strong> maggiore basta iterare il metodo sui sottografi ottenuti.</li><li><strong>metodi agglomerativi</strong>, in cui si parte considerando ogni singolo nodo una comunit√†, e man mano si aggiungono gli archi del grafo finch√© non si otterranno un numero di comunit√† desiderato con un livello di coesione accettabile.</li></ul><p>Osservare che entrambi i metodi consentono di ottenere delle <strong>partizioni nidificate</strong> (<strong>nested</strong>), infatti nel metodo partitivo si genera una partizione a partire da una pi√π grande (approccio <strong>top-down</strong>), e nel metodo agglomerativo si genera una partizione come composizione di altre pi√π piccole (approccio <strong>bottom-up</strong>).</p><p><img src=https://Alessandrostr95.github.io//ar-lesson08-img1.png width=350 alt="Schema di partizione metodo partitivo.|350"></p><p><img src=https://Alessandrostr95.github.io//ar-lesson08-img2.png width=350 alt="Schema di partizione metodo agglomerativo.|350">
Entrambi i metodi hanno quindi uno <em>schema di partizione</em> ad albero.</p><p>Osservare infine che entrambi i metodi richiedono la scelta di un arco da rimuovere o aggiungere ad ogni passo.</p><hr><a href=#edge-betweenness><h2 id=edge-betweenness><span class=hanchor arialabel=Anchor># </span>Edge-Betweenness</h2></a><p>Il concetto di <strong>betweennes</strong> di un arco √® sfruttato come criterio di rimozione degli archi nei metodi partitivi di partizionamento precedentemente accennati.
Tale concetto a sua volta si basa sulle propriet√† di un arco di essere <em>bridge</em> o <em>local bridge</em>.</p><p>Sappiamo che per definizione, rimuovere un arco bridge disconnette due porzioni di una rete, mentre rimuovere un local bridge certamente peggiora la connettivit√† tra due comunit√†.</p><p>Sappiamo anche che gli archi bridge e local brdige sono dei <em>weak ties</em>.
Perci√≤, rimuovendo tutti i weak ties da una rete rimangono solamente gruppi di nodi connessi da relazioni forti (<em>strong ties</em>), e tali gruppi rispecchiano il concetto intuitivo di comunit√† (ovvero gruppi di persone collegati da legami forti).</p><p>Purtroppo per√≤ esistono casi in cui anche rimuovendo tutti i weak ties non avviene un partizionamento in comunit√†.</p><p><img src=https://Alessandrostr95.github.io//ar-lesson08-img3.png width=350 alt="Controesempio: in blu i weak ties e in rosso gli strong ties.|350"></p><p>Infatti, considerando il precedente controesempio, pur rimuovendo l&rsquo;arco rosso non avremo un partizionamento.
Invece √® evidente che c&rsquo;√® una comunit√† composta da una clique a destra e una composta da una clique a sinistra.
Per quanto riguarda il nodo centrale esso pu√≤ essere inserito indistintamente i una delle due comunit√†.</p><p>Perci√≤ come criterio potremmo considerare la quantit√† di <strong>traffico</strong> (o <strong>flusso</strong>) di informazioni che passa attraverso gli archi.</p><p>Possiamo considerare come &ldquo;nuovi archi ponte&rdquo; tutti quegli archi attraverso i quali passa una grande quantit√† di flusso, e che se rimossi rendono pi√π difficile la comunicazione tra due comunit√†.</p><p>Secondo questo criterio possiamo rimuovere gli archi sui quali passa maggior flusso, finch√© non otterremo un partizionamento accettabile della rete.</p><p>Pi√π formalmente, considerando un grafo <u>non diretto</u> $G = (V,E)$, definiamo con $\sigma_{st}(u,v)$ il numero di
<a href=https://en.wikipedia.org/wiki/Shortest_path_problem rel=noopener>shortest-paths</a> $\pi^\star(s,t)$ (o <em>camminimi minimi</em>) tra $s$ e $t$ che passano per l&rsquo;arco $(u,v)$.</p><p>Definiamo poi con $b_{st}(u,v)$ la <strong>betweennes dell&rsquo;arco</strong> $(u,v)$ <strong>rispetto alla coppia</strong> $s,t$ come la <strong>frazione</strong> di shortest path $\pi^\star(s,t)$ che passano per l&rsquo;arco $(u,v)$ $$
\begin{align*}
\sigma_{st} &= \vert \lbrace \pi^\star(s,t) \rbrace \vert\\b_{st}(u,v) &= \frac{\sigma_{st}(u,v)}{\sigma_{st}}
\end{align*}
$$Definiamo infine la <strong>betweenness</strong> $b(u,v)$ di un arco $(u,v)$ come la <em>semi-somma</em> di tutte le betweenness relative $b_{st}(u,v)$, per ogni coppia di nodi $s,t$
$$b(u,v) = \frac{1}{2} \sum_{(s,t) \in \binom{V}{2}} b_{st}(u,v)$$
Notare che il fattore $1/2$ √® necessario per evitare di contare le ripetizioni, del tipo $b_{st}(u,v)$ e $b_{ts}(u,v)$.</p><p>Analogamente alla <strong>edge-betweenness</strong> si pu√≤ definire una <strong>node-betweenness</strong>, seguendo la stessa definizione.</p><a href=#il-metodo-di-girvan-newman><h2 id=il-metodo-di-girvan-newman><span class=hanchor arialabel=Anchor># </span>Il metodo di Girvan-Newman</h2></a><p>Il metodo di <em>Girvan-Newman</em> √® un metodo partitivo per il partizionamento, basato sul concetto di <em>edge-betweenness</em>, abbastanza semplice.
I passaggi sono i seguenti:</p><ol><li>Si calcola l&rsquo;arco $(u,v)$ con betweenness $b(u,v)$ <strong>massima</strong>, e lo si rimuove.</li><li>Se il grafo residuo risulta partizionato con in una granularit√† desiderata allora abbiamo concluso.</li><li>Se cos√¨ non fosse si ricalcola il nuovo arco con betweenness massima del nuovo grafo e si itera finch√© non si ottiene il risultato desiderato.</li></ol><p>L&rsquo;algoritmo di suo √® abbastanza semplice, l&rsquo;unico problema √® il calcolo delle betweenness degli archi.</p><p>Purtroppo non si pu√≤ applicare un approccio brute force calcolando tutti gli shortest path altrimenti la complessit√† risulterebbe esponenziale.</p><p><u>Serve quindi un approccio pi√π efficiente.</u></p><a href=#algoritmo-per-il-calcolo-della-betweenness><h2 id=algoritmo-per-il-calcolo-della-betweenness><span class=hanchor arialabel=Anchor># </span>Algoritmo per il calcolo della betweenness</h2></a><p>Per ogni nodo $s \in V$ l&rsquo;algoritmo del calcolo della betweenness degli archi si suddivide in tre fasi:</p><ol><li>Calcolare il sottografo $T(s)$ composto dall&rsquo;<em>unione</em> degli alberi di camminimi minimi radicati in $s$. Anche se il numero di tali alberi pu√≤ essere esponenziale, in realt√† il calcolo di $T(s)$ pu√≤ essere effettuato in tempo polinomiale con una visita in ampiezza <code>BFS</code> con le dovute modifiche. ^8a6088</li><li>Mediante una visita <code>top-down</code> calcolo i valori $\sigma_{sv}$ per ogni $v \in V \setminus \lbrace s \rbrace$, e questo vedremo si pu√≤ fare in tempo polinomiale. ^853300</li><li>Infine mediante una visita <code>bottom-up</code>, e grazie a quanto calcolato nel punto 2, calcolo per ogni arco $(u,v) \in T(s)$ tutte le betweennes relative a shortest paths che partono da $s$, ovvero il valore $$b_s(u,v) = \sum_{t \in V \setminus \lbrace s \rbrace} b_{st}(u,v) ;; \forall (u,v) \in T(s)$$ ^f5c61f</li></ol><p>Per concludere, una volta eseguiti i punti
<a href=/AR/8-Communities-Part-2/ rel=noopener class=internal-link data-src=/AR/8-Communities-Part-2/>(1)</a>,
<a href=/AR/8-Communities-Part-2/ rel=noopener class=internal-link data-src=/AR/8-Communities-Part-2/>(2)</a> e
<a href=/AR/8-Communities-Part-2/ rel=noopener class=internal-link data-src=/AR/8-Communities-Part-2/>(3)</a> per ogni nodo $s \in V$, possiamo ricavare i valori delle betweenness come segue
$$b(u,v) = \frac{1}{2} \sum_{s \in V} b_s(u,v)$$
Osserviamo che nel punto <code>3</code> calcoliamo $b_s(u,v)$ solo per gli archi di $T(s)$, in quanto se $(u,v)$ non appartiene al sottografo degli shortest path $T(s)$ allora vuol dire che non appartiene nessun shortest path, e quindi non avrebbe senso calcolarlo (per definizione di betweenness).</p><p>Andiamo ora a vedere un esempio pratico che mostra anche come eseguire i tre passi dell&rsquo;algoritmo del calcolo della betweenness.</p><a href=#fase-1><h3 id=fase-1><span class=hanchor arialabel=Anchor># </span>Fase 1</h3></a><p>Per calcolare $T(s)$ basta effettuare una visita in ampiezza <code>BFS</code> opportunamente modificata.</p><p>Definiamo con $L_h$ l&rsquo;insieme di tutti i nodi a distanza $h$ dalla sorgente $s$.
Diremo che un nodo $v$ si trova al <strong>livello</strong> $h$ se $v \in L_h$.</p><p>Se un nodo $v$ si trova al livello $h$, allora certamente <strong>tutti</strong> i cammini minimi da $s$ a $v$ termineranno con archi che partono da $L_{h-1}$.
Perci√≤, tutti gli archi $(u,v)$ con $u \in L_{h-1}$ e $v \in L_h$ faranno parte di $T(s)$.</p><p>Perci√≤ possiamo calcolare $T(s)$ nella seguente maniera:</p><ol><li>Poniamo inizialmente $L_0 = \lbrace s \rbrace$ e $T(s) = \emptyset$.</li><li>Per ogni $h \geq 0$ calcoliamo $L_{h+1}$ come tutti quei nodi <strong>fuori</strong> $L_0 \cup L_1 \cup &mldr; \cup L_h$ tali che hanno almeno un vicino in $v \in L_h$, ovvero come $$ L_{h+1} \equiv \lbrace v \in V \setminus (L_0 \cup L_1 \cup &mldr; \cup L_h) | \exists u \in L_h : (u,v) \in E \rbrace$$</li><li>Calcolato $L_{h+1}$ poniamo $T(s)$ come $$T(s) = T(s) \cup \lbrace (u,v) \in E | u \in L_h \land v \in L_{h+1} \rbrace$$
<img src=https://Alessandrostr95.github.io//ar-lesson08-img4.png width=400 alt="Costruzione sottografo dei cammini minimi.|400"></li></ol><a href=#fase-2><h3 id=fase-2><span class=hanchor arialabel=Anchor># </span>Fase 2</h3></a><p>Calcolato $T(s)$, possiamo sfruttarlo per calcolare, per ogni $v \in V$, la quantit√† $\sigma_{sv}$, ovvero il numero di cammini minimi che vanno da $s$ a $v$.</p><p>Iniziamo osservando che per ogni nodo $v$ nel livello 1, il numero di cammini minimi sar√† pari ad 1 (perch√© $v$ √® diretto vicino di $s$).</p><p>Invece al livello 2, il numero di cammini minimi di un generico nodo $v \in L_2$ √® pari alla somma di tutti i $\sigma_{su}$, tali che esiste $(u,v)$ con $u \in L_1$. Pi√π in generale, per ogni $v \in L_h$, possiamo calcolare $\sigma_{sv}$ con la seguente formula ricorsiva
$$
\begin{align*}
\sigma_{sv} &= 1 &h = 1\\\sigma_{sv} &= \sum_{u \in N(v) \cap L_{h-1}} \sigma_{su} &h > 1
\end{align*}
$$</p><p><img src=https://Alessandrostr95.github.io//ar-lesson08-img5.png width=550 alt="Calcolo numero dei cammini minimi.|550"></p><p>Notare che questa fase viene eseguita facendo una visita <code>top-down</code> del sottografo $T(s)$.</p><a href=#fase-3><h3 id=fase-3><span class=hanchor arialabel=Anchor># </span>Fase 3</h3></a><p>Nella terza fase dobbiamo calcolare per ogni arco $(u,v) \in T(s)$ la quantit√† di flusso che ci passa sopra rispetto a $s$, ovvero $$b_s(u,v) = \sum_{t \in V \setminus \lbrace s \rbrace} b_{st}(u,v)$$
Per fare ci√≤ in questo caso faremo una visita <code>bottom-up</code> di $T(s)$.</p><p>Si $d$ il numero di livelli in $T(s)$, e consideriamo un arco $(y,x)$ con $y \in L_{d-1}$ e $x \in L_d$.</p><p>Osserviamo che tutti gli shortest path che partono da $s$ e passano attravero l&rsquo;arco $(y,x)$ sono tutti shortest path che terminano in $x$.</p><p>Perci√≤ il flusso che passa su $(y,x)$ rispetto a $s$ sar√† pari al rapporto tra il numero di shortest path che vanno da $s$ a $y$ (ovvero $\sigma_{sy}$) e il numero complessivo di shortest path che vanno da $s$ ad $x$ (ovvero $\sigma_{sx}$).
$$b_s(y,x) = \sum_{t \in V \setminus \lbrace s \rbrace} b_{st}(y,x) = b_{sx}(y,x) = \frac{\sigma_{sx}(y,x)}{\sigma_{sx}} = \frac{\sigma_{sy}}{\sigma_{sx}}$$
Analogamente possiamo applicare questo ragionamento per tutti gli archi che collegano nodi dell&rsquo;ultimo livello, come mostrato nella seguente
<a href=/AR/8-Communities-Part-2/ rel=noopener class=internal-link data-src=/AR/8-Communities-Part-2/>figura</a>.</p><p><img src=https://Alessandrostr95.github.io//ar-lesson08-img6.png width=550 alt="Calcolo di $b_s(y, x)$.|550"> ^b81567</p><p>Adesso, saliamo di un livello, e consideriamo gli archi che entrano nel livello $L_{d-1}$.</p><p>Rifacendoci all&rsquo;
<a href=/AR/8-Communities-Part-2/ rel=noopener class=internal-link data-src=/AR/8-Communities-Part-2/>immagine in esempio</a>, consideriamo l&rsquo;arco $(z, y)$, con $z \in L_{d-2}$ e $y \in L_{d-1}$.
<img src=https://Alessandrostr95.github.io//ar-lesson08-img7.png width=auto alt="Esempio da considerare."> ^a89eb9</p><p>Osserviamo che tra tutti i cammini minimi che passano per l&rsquo;arco $(z, y)$, una parte saranno cammini che termineranno in $y$, e una parte saranno cammini minimi che andranno ai nodi di livello inferiore.</p><p>Perci√≤ la frazione di shortest path che, partendo da $s$, passano per $(z, y)$ √® pari alla somma dei seguenti fattori:</p><ul><li>La frazione degli shortest path da $s$ ad $y$, ovvero $\frac{\sigma_{sz}}{\sigma_{sy}}$.</li><li>Per ogni <em>diretto discendente</em><sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> $x$ di $y$, una frazione $\frac{\sigma_{sz}}{\sigma_{sy}}$ della frazione di shortest path da $s$ ad $x$ che passano per l&rsquo;arco $(y,x)$, ovvero $\frac{\sigma_{sz}}{\sigma_{sy}} \cdot \frac{\sigma_{sy}}{\sigma_{sx}} = \frac{\sigma_{sz}}{\sigma_{sx}}$.</li></ul><p>Quindi, rifacendoci all&rsquo;esempio, avremo che $$ b_s(z,y) = \frac{\sigma_{sz}}{\sigma_{sy}} + \frac{\sigma_{sz}}{\sigma_{sy}} \cdot \frac{\sigma_{sy}}{\sigma_{sx}} = \frac{1}{3} + \frac{1}{3}\cdot\frac{3}{5} = \frac{8}{15}$$
Cos√¨ facendo abbiamo definito un metodo <code>bottom-up</code> per il calcolo tutti i valori $b_s(u,v)$.</p><p><img src=https://Alessandrostr95.github.io//ar-lesson08-img8.png width=550 alt="Calcolo di tutti i valori $b_s(u, v)$.|550"></p><a href=#fase-finale---calcolo-betweenness><h3 id=fase-finale---calcolo-betweenness><span class=hanchor arialabel=Anchor># </span>Fase finale - Calcolo Betweenness</h3></a><p>Concludendo, possiamo calcolare la betweennes di tutti gli archi come gi√† descritto in precedenza $$b(u,v) = \frac{1}{2} \sum_{s \in V} b_s(u,v)$$
Notiamo che questa procedura permette di calcolare la betweennes degli archi in tempo <em>polinomiale</em> nella grandezza della rete (e non esponenziale).</p><p>Infatti la
<a href=/AR/8-Communities-Part-2/ rel=noopener class=internal-link data-src=/AR/8-Communities-Part-2/>fase 1</a> √® una semplice visita in ampiezza del grafo (e si pu√≤ calcolare in tempo $O(|V| + |E|)$), la
<a href=/AR/8-Communities-Part-2/ rel=noopener class=internal-link data-src=/AR/8-Communities-Part-2/>fase 2</a> √® un&rsquo;ulteriore visita in ampiezza di $T(s)$ (e si pu√≤ calcolare ancora in tempo $O(|V| + |E|)$), e infine la
<a href=/AR/8-Communities-Part-2/ rel=noopener class=internal-link data-src=/AR/8-Communities-Part-2/>fase 3</a> √® nuovamente una visita in ampiezza, partendo per√≤ dal livello pi√π basso (acnora una volta $O(|V| + |E|)$).</p><p>Dato che bisogna iterare questo procedimento per ogni nodo del grafo, e dato che nel caso peggiore abbiamo grafi molto densi con $\Theta(n^2)$ archi, la complessit√† temporale dell&rsquo;esecuzione di questo algoritmo per il calcolo delle betweennes sar√† $O(nm) \in O(n^3)$.</p><a href=#rilassare-il-modello><h1 id=rilassare-il-modello><span class=hanchor arialabel=Anchor># </span>Rilassare il modello</h1></a><p>La definizione teorica discussa fin ora era basata su assunzioni forti:
un arco poteva essere un <em>bridge edge</em> o no, e poteva rappresentare uno <em>strong</em> o <em>weak tie</em>.
Riportare i concetti di <em>bridge edges</em> e <em>strong/waeak ties</em> in una rete sociale reale √® per√≤ un&rsquo;assunzione <u>troppo forte</u>.
Per esempio in una rete molto grande √® molto raro trovare dei <em>bridge edges</em>, inoltre le persone non classificano le proprie relazioni in maniera dicotomica <code>strong/weak</code>, in genere ci sono moltissime sfumature.</p><p>Per rilassare i concetti di <em>strong</em> e <em>waeak ties</em> possiamo definire un modello in cui le relazioni tra due nodi della rete sono <strong>pesate</strong> in maniera numerica.
Quindi invece di considerare una rete $G = (V, S \cup W)$, potremmo per esempio definire una rete $G = (V,E,w)$ dove $w : E \rightarrow \mathbb{N}$ √® una funzione che rappresenta la <em>forza</em> delle relazioni, pi√π √® alto il valore $w(u,v)$ pi√π la relazione tra i nodi $u$ e $v$ √® <u>forte</u>.</p><p>Per quanto riguarda il concetto di <em>bridge edge</em>, possiamo considerare il concetto di <strong>neighborhood overlap</strong>, ovvero la frazie di amicie in comune che hanno due nodi. $$NO(u,v) = \frac{ \vert N(u) \cap N(v) \vert }{ \vert N(u) \cup N(v) - \lbrace u,v \rbrace \vert }$$
Osserviamo che un <em>local bridge</em> $(u,v)$ ha un neighborhood overlap $NO(u,v) = 0$.</p><p>Sappiamo che i due concetti <em>bridge edges</em> e <em>strong/waeak ties</em> sono correllati, ovvero sappiamo che qualora una rete $G$ soddisfa la
<a href=/AR/7-Communities-Part-1/ rel=noopener class=internal-link data-src=/AR/7-Communities-Part-1/>STCP</a> allora tutti i <em>local bridge</em> sono <em>weak ties</em>.
Ci√≤ che si pu√≤ chiedere √® se questo tipo di relazione persiste anche nel modello rilassato appena descritto.</p><p>Data la generalit√† del modello rilassato, √® pi√π complesso andare a fare un&rsquo;analisi rigorosa. In aiuto per√≤ esistono dei risultati di tipo empirico risultati da un esperimento di <em>Onnela et al</em> del 2007.
Vennero presi i registri di una compagnia telefonica e costruito (in maniera anonima ?) sulla basse di essi un grafo, seguendo i seguenti criteri:</p><ol><li>gli indirizzi telefonici vennero rappresentati dai nodi della rete.</li><li>esisteva un arco tra due nodi se essi si erano scambiati almeno una telefonata nelle ultime 18 settimane.</li><li>gli archi vennero persati in base alla durata delle chiamate effettuate, pi√π due nodi parlano al telefono, pi√π √® alto il peso dell&rsquo;arco.</li></ol><p>Tale rete rappresentava una rete socialre reale, in quanto i numeri telefonici erano ad uso <em>comune</em> (e non <em>commericale</em> o <em>aziendale</em>), e inoltre la compagnia telefonica che ha fornito i dati copriva una vasta area di una popolazione.
A conferma, erano presenti alcune caratteristiche fondamentali delle reti sociali, come per esempio la presenza di <em>componenti giganti</em> (in questo caso grade l'84% della rete).</p><p>L&rsquo;esperimento in questione consistette in due fasi:</p><ol><li>nella prima vennero rimossi gli archi in ordine <em>decrescente</em> di peso, e si osserv√≤ che la rete si disconnetteva molto lentamente.</li><li>nella seconda fase si fece l&rsquo;opposto, ovvero vennero rimossi gli archi a partire da quelli meno pesati, osservando invece che la rete si disconnetteva molto pi√π velocemente.</li></ol><p>Il risultato di questo esperimento suggerisce in maniera empirica che anche nel modello pi√π rilassato c&rsquo;√® una connessione tra neighborhood overlap e peso di un arco.
Dato che la rimozione di archi con peso basso, rendeva pi√π difficile la comunicazione tra gruppi di nodi, √® sensato pensare che tanto pi√π il peso di un arco √® basso tanto pi√π √® bassa la neighborhood overlap di tale arco.</p><p><img src=https://Alessandrostr95.github.io//ar-lesson08-img9.png width=400 alt="Esempio di come cresce la neighborhood di un arco $N(u,v)$ al crescere del suo peso $w(u,v)$.|400"></p><a href=#osservazioni-finali><h1 id=osservazioni-finali><span class=hanchor arialabel=Anchor># </span>Osservazioni finali</h1></a><p>Ricapitolando tutto quello detto fin ora, una rete sociale √® sostanzialmente un agglomerato di gruppi densamente connessi tra di loro con relazioni forti, i quali gruppi sono a loro volta connessi tramite una serie di connessioni deboli.</p><p>Concettualmente sappiamo che in un contesto sociale l&rsquo;appartenenza ad un gruppo comporta vantaggi di vitale importanza.
In genere pi√π una persona √® ben inserita in un gruppo, ovvero pi√π ha fiducia di chi gli sta intorno, pi√π ne trae vantaggio.</p><p>Contrariamente, l&rsquo;esperimento di Granovetter ci suggerisce che avvolte √® altrettanto necessario avere contatti con gente appartenente ad altri gruppi, in quanto cos√¨ facendo avremo accesso a differenti fonti di informazioni potenzialmente molto convenienti.</p><p>Queste due osservazioni ci permettono di inutire che i vantaggi dei nodi non dipendono solamente dall&rsquo;appartenenza a comunit√†, bens√¨ anche dalla posizione di tali nodi e da quanto sono ben inseriti o meno all&rsquo;interno dei rispettivi gruppi.
Per aiutarci definiamo il concetto di <strong>embeddedness</strong> di un arco $(u,v)$ come la quantit√† di vicinato in comune ai due estremi di un arco, ovvero $$\text{Emb}(u,v) = \vert N(u) \cap N(v) \vert$$
Osserviamo che un <em>local bridge</em> √® un arco con embeddedness pari a $0$.</p><p>Pi√π la embeddedness di un arco √® alta, pi√π i due suoi vicini sono ben integrati tra di loro.
Analogamente, un nodo che tani archi incidenti con embeddedness alta √® un nodo che √® ben integrato nel gruppo a cui appartiene.</p><p><img src=https://Alessandrostr95.github.io//ar-lesson08-img10.png width=500 alt=|500></p><p>Nell&rsquo;esempio in precedenza si pu√≤ notare che il nodo <code>A</code> √® ben integrato nella sua comunit√†, in quanto ricopre una <strong>posizione centrale</strong>.
Infatti tutti i suoi archi incidenti hanno una embeddedness alta.</p><p>Contrariamente il nodo <code>B</code> ricopre una posizione marginale nella sua comunit√†, e infatti ha pochi archi incidenti con embeddedness alta.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>ovvero <strong>NP-completo</strong>.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>ovvero quei nodi collegati ad $y$ da un arco e che si trovano al successivo livello pi√π in basso.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://Alessandrostr95.github.io/js/graph.abd4bc2af3869a96524d7d23b76152c7.js></script></div></div><div id=contact_buttons><footer><p>Made by Alessandro Straziota using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, ¬© 2022</p><ul><li><a href=https://Alessandrostr95.github.io/>Home</a></li><li><a href=https://twitter.com/Alessandro_357>Twitter</a></li><li><a href=https://github.com/Alessandrostr95>Github</a></li></ul></footer></div></div></body></html>